var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React from 'react';

var extractPropsFromString = function extractPropsFromString(attr) {
  var propsStr = attr.match(/\s*([^=]*)\s*=\s*"([^"]*)"/gi) || [];
  return Object.assign.apply(Object, [{}].concat(propsStr.map(function (s) {
    var _ref;

    var arr = s.split('=');
    return _ref = {}, _ref[(arr[0] || '').trim()] = (arr[1] || '').replace(/\s*["]+/g, ''), _ref;
  }).flat()));
};

var cloneElement = function cloneElement(el, lastChild) {
  if (!el) return [];
  if (!Array.isArray(lastChild)) lastChild = [lastChild];
  if (el.props && el.props.children) {
    return React.cloneElement(el, {}, cloneElement(el.props.children, lastChild));
  } else if (el.props) {
    return React.cloneElement(el, {}, [].concat(lastChild));
  } else {
    return [el, [].concat(lastChild)];
  }
};

/**
 * 
 * const fn = (tag, props) => {
    if (tag === 'mention') {
      return <MentionBlock />;
    }
    if (tag === 'bold') {
      return <b />;
    }
    if (tag === 'italic') {
      return <i />;
    }
  }
 */

var parseText = function parseText() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  var tags = [];
  var preTreeLen = 0;
  var nodes = [];
  var matches = text.matchAll(/<\s*(\/\s*)*([^>\s]*)[^><]*>/gi);
  matches = Array.from(matches);

  for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref2;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref2 = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref2 = _i.value;
    }

    var match = _ref2;
    var substring = match[0],
        isClosing = match[1],
        tag = match[2];

    var index = match['index'];
    tag = (tag || '').trim();
    isClosing = (isClosing || '').trim();
    substring = (substring || '').trim();
    if (!isClosing) {
      tags.push({ tag: tag, substring: substring, index: index });
    } else if (isClosing && tags.length > 0 && tag === tags[tags.length - 1].tag) {
      var tagObj = tags.pop();
      var _substring = tagObj.substring,
          _tag = tagObj.tag;

      var attr = _substring.replace(/[<>]/gi, '').replace(_tag, '');
      var props = extractPropsFromString(attr);
      var JsxEl = fn(_tag, _extends({}, props));

      JsxEl = cloneElement(JsxEl, text.slice(text.indexOf('>', tagObj.index) + 1, text.indexOf('<', tagObj.index + 1)));

      nodes = [].concat(nodes);

      if (preTreeLen <= tags.length) {
        nodes = [].concat(nodes, [JsxEl, text.slice(text.indexOf('>', index) + 1, text.indexOf('<', index + 1) == -1 ? Infinity : text.indexOf('<', index + 1))]);
      } else {
        nodes = cloneElement(JsxEl, nodes);
      }
      preTreeLen = tags.length;
    } else {
      throw Error('Invalid string, no matching tag "' + tag + '"');
    }
  }
  if (tags.length !== 0) {
    throw Error('Invalid string, no matching tags : "' + (tags.map(function (t) {
      return t.tag;
    }) || '').toString() + '"');
  }
  return [text.slice(0, text.indexOf('<') == -1 ? Infinity : text.indexOf('<'))].concat(nodes);
};

export default parseText;