{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar has = require('./hasProperty');\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  function Translator(locales) {\n    var _this = this;\n\n    this.locale = {\n      strings: {},\n      pluralize: function pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n\n        return 1;\n      }\n    };\n\n    if (Array.isArray(locales)) {\n      locales.forEach(function (locale) {\n        return _this._apply(locale);\n      });\n    } else {\n      this._apply(locales);\n    }\n  }\n\n  var _proto = Translator.prototype;\n\n  _proto._apply = function _apply(locale) {\n    if (!locale || !locale.strings) {\n      return;\n    }\n\n    var prevLocale = this.locale;\n    this.locale = _extends({}, prevLocale, {\n      strings: _extends({}, prevLocale.strings, locale.strings)\n    });\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;\n  }\n  /**\n   * Takes a string with placeholder variables like `%{smart_count} file selected`\n   * and replaces it with values from options `{smart_count: 5}`\n   *\n   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n   *\n   * @param {string} phrase that needs interpolation, with placeholders\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {string} interpolated\n   */\n  ;\n\n  _proto.interpolate = function interpolate(phrase, options) {\n    var _String$prototype = String.prototype,\n        split = _String$prototype.split,\n        replace = _String$prototype.replace;\n    var dollarRegex = /\\$/g;\n    var dollarBillsYall = '$$$$';\n    var interpolated = [phrase];\n\n    for (var arg in options) {\n      if (arg !== '_' && has(options, arg)) {\n        // Ensure replacement value is escaped to prevent special $-prefixed\n        // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n        // be escaped with \"$\" itself, and we need two in the resulting output.\n        var replacement = options[arg];\n\n        if (typeof replacement === 'string') {\n          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);\n        } // We create a new `RegExp` each time instead of using a more-efficient\n        // string replace so that the same argument can be replaced multiple times\n        // in the same phrase.\n\n\n        interpolated = insertReplacement(interpolated, new RegExp('%\\\\{' + arg + '\\\\}', 'g'), replacement);\n      }\n    }\n\n    return interpolated;\n\n    function insertReplacement(source, rx, replacement) {\n      var newParts = [];\n      source.forEach(function (chunk) {\n        // When the source contains multiple placeholders for interpolation,\n        // we should ignore chunks that are not strings, because those\n        // can be JSX objects and will be otherwise incorrectly turned into strings.\n        // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n        if (typeof chunk !== 'string') {\n          return newParts.push(chunk);\n        }\n\n        split.call(chunk, rx).forEach(function (raw, i, list) {\n          if (raw !== '') {\n            newParts.push(raw);\n          } // Interlace with the `replacement` value\n\n\n          if (i < list.length - 1) {\n            newParts.push(replacement);\n          }\n        });\n      });\n      return newParts;\n    }\n  }\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */\n  ;\n\n  _proto.translate = function translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */\n  ;\n\n  _proto.translateArray = function translateArray(key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(\"missing string: \" + key);\n    }\n\n    var string = this.locale.strings[key];\n    var hasPluralForms = typeof string === 'object';\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        var plural = this.locale.pluralize(options.smart_count);\n        return this.interpolate(string[plural], options);\n      } else {\n        throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n      }\n    }\n\n    return this.interpolate(string, options);\n  };\n\n  return Translator;\n}();","map":{"version":3,"sources":["/home/devnineteen/Desktop/Projects/Evergreen-client/node_modules/@uppy/utils/lib/Translator.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","has","require","module","exports","Translator","locales","_this","locale","strings","pluralize","n","Array","isArray","forEach","_apply","_proto","prevLocale","interpolate","phrase","options","_String$prototype","String","split","replace","dollarRegex","dollarBillsYall","interpolated","arg","replacement","insertReplacement","RegExp","rx","newParts","chunk","push","raw","list","translate","translateArray","join","Error","string","hasPluralForms","smart_count","plural"],"mappings":"AAAA,SAASA,QAAT,GAAoB;AAAEA,EAAAA,QAAQ,GAAGC,MAAM,CAACC,MAAP,IAAiB,UAAUC,MAAV,EAAkB;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,UAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAtB;;AAA2B,WAAK,IAAII,GAAT,IAAgBD,MAAhB,EAAwB;AAAE,YAAIN,MAAM,CAACQ,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCJ,MAArC,EAA6CC,GAA7C,CAAJ,EAAuD;AAAEL,UAAAA,MAAM,CAACK,GAAD,CAAN,GAAcD,MAAM,CAACC,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,WAAOL,MAAP;AAAgB,GAA5P;;AAA8P,SAAOH,QAAQ,CAACY,KAAT,CAAe,IAAf,EAAqBP,SAArB,CAAP;AAAyC;;AAE7T,IAAIQ,GAAG,GAAGC,OAAO,CAAC,eAAD,CAAjB;AACA;;;;;;;;;;;;;AAaAC,MAAM,CAACC,OAAP,GAAiB,aAAa,YAAY;AACxC;;;AAGA,WAASC,UAAT,CAAoBC,OAApB,EAA6B;AAC3B,QAAIC,KAAK,GAAG,IAAZ;;AAEA,SAAKC,MAAL,GAAc;AACZC,MAAAA,OAAO,EAAE,EADG;AAEZC,MAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBC,CAAnB,EAAsB;AAC/B,YAAIA,CAAC,KAAK,CAAV,EAAa;AACX,iBAAO,CAAP;AACD;;AAED,eAAO,CAAP;AACD;AARW,KAAd;;AAWA,QAAIC,KAAK,CAACC,OAAN,CAAcP,OAAd,CAAJ,EAA4B;AAC1BA,MAAAA,OAAO,CAACQ,OAAR,CAAgB,UAAUN,MAAV,EAAkB;AAChC,eAAOD,KAAK,CAACQ,MAAN,CAAaP,MAAb,CAAP;AACD,OAFD;AAGD,KAJD,MAIO;AACL,WAAKO,MAAL,CAAYT,OAAZ;AACD;AACF;;AAED,MAAIU,MAAM,GAAGX,UAAU,CAACR,SAAxB;;AAEAmB,EAAAA,MAAM,CAACD,MAAP,GAAgB,SAASA,MAAT,CAAgBP,MAAhB,EAAwB;AACtC,QAAI,CAACA,MAAD,IAAW,CAACA,MAAM,CAACC,OAAvB,EAAgC;AAC9B;AACD;;AAED,QAAIQ,UAAU,GAAG,KAAKT,MAAtB;AACA,SAAKA,MAAL,GAAcpB,QAAQ,CAAC,EAAD,EAAK6B,UAAL,EAAiB;AACrCR,MAAAA,OAAO,EAAErB,QAAQ,CAAC,EAAD,EAAK6B,UAAU,CAACR,OAAhB,EAAyBD,MAAM,CAACC,OAAhC;AADoB,KAAjB,CAAtB;AAGA,SAAKD,MAAL,CAAYE,SAAZ,GAAwBF,MAAM,CAACE,SAAP,IAAoBO,UAAU,CAACP,SAAvD;AACD;AACD;;;;;;;;;;;AAXA;;AAwBAM,EAAAA,MAAM,CAACE,WAAP,GAAqB,SAASA,WAAT,CAAqBC,MAArB,EAA6BC,OAA7B,EAAsC;AACzD,QAAIC,iBAAiB,GAAGC,MAAM,CAACzB,SAA/B;AAAA,QACI0B,KAAK,GAAGF,iBAAiB,CAACE,KAD9B;AAAA,QAEIC,OAAO,GAAGH,iBAAiB,CAACG,OAFhC;AAGA,QAAIC,WAAW,GAAG,KAAlB;AACA,QAAIC,eAAe,GAAG,MAAtB;AACA,QAAIC,YAAY,GAAG,CAACR,MAAD,CAAnB;;AAEA,SAAK,IAAIS,GAAT,IAAgBR,OAAhB,EAAyB;AACvB,UAAIQ,GAAG,KAAK,GAAR,IAAe3B,GAAG,CAACmB,OAAD,EAAUQ,GAAV,CAAtB,EAAsC;AACpC;AACA;AACA;AACA,YAAIC,WAAW,GAAGT,OAAO,CAACQ,GAAD,CAAzB;;AAEA,YAAI,OAAOC,WAAP,KAAuB,QAA3B,EAAqC;AACnCA,UAAAA,WAAW,GAAGL,OAAO,CAACzB,IAAR,CAAaqB,OAAO,CAACQ,GAAD,CAApB,EAA2BH,WAA3B,EAAwCC,eAAxC,CAAd;AACD,SARmC,CAQlC;AACF;AACA;;;AAGAC,QAAAA,YAAY,GAAGG,iBAAiB,CAACH,YAAD,EAAe,IAAII,MAAJ,CAAW,SAASH,GAAT,GAAe,KAA1B,EAAiC,GAAjC,CAAf,EAAsDC,WAAtD,CAAhC;AACD;AACF;;AAED,WAAOF,YAAP;;AAEA,aAASG,iBAAT,CAA2BnC,MAA3B,EAAmCqC,EAAnC,EAAuCH,WAAvC,EAAoD;AAClD,UAAII,QAAQ,GAAG,EAAf;AACAtC,MAAAA,MAAM,CAACmB,OAAP,CAAe,UAAUoB,KAAV,EAAiB;AAC9B;AACA;AACA;AACA;AACA,YAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,iBAAOD,QAAQ,CAACE,IAAT,CAAcD,KAAd,CAAP;AACD;;AAEDX,QAAAA,KAAK,CAACxB,IAAN,CAAWmC,KAAX,EAAkBF,EAAlB,EAAsBlB,OAAtB,CAA8B,UAAUsB,GAAV,EAAe5C,CAAf,EAAkB6C,IAAlB,EAAwB;AACpD,cAAID,GAAG,KAAK,EAAZ,EAAgB;AACdH,YAAAA,QAAQ,CAACE,IAAT,CAAcC,GAAd;AACD,WAHmD,CAGlD;;;AAGF,cAAI5C,CAAC,GAAG6C,IAAI,CAAC3C,MAAL,GAAc,CAAtB,EAAyB;AACvBuC,YAAAA,QAAQ,CAACE,IAAT,CAAcN,WAAd;AACD;AACF,SATD;AAUD,OAnBD;AAoBA,aAAOI,QAAP;AACD;AACF;AACD;;;;;;;AArDA;;AA8DAjB,EAAAA,MAAM,CAACsB,SAAP,GAAmB,SAASA,SAAT,CAAmB1C,GAAnB,EAAwBwB,OAAxB,EAAiC;AAClD,WAAO,KAAKmB,cAAL,CAAoB3C,GAApB,EAAyBwB,OAAzB,EAAkCoB,IAAlC,CAAuC,EAAvC,CAAP;AACD;AACD;;;;;;;AAHA;;AAYAxB,EAAAA,MAAM,CAACuB,cAAP,GAAwB,SAASA,cAAT,CAAwB3C,GAAxB,EAA6BwB,OAA7B,EAAsC;AAC5D,QAAI,CAACnB,GAAG,CAAC,KAAKO,MAAL,CAAYC,OAAb,EAAsBb,GAAtB,CAAR,EAAoC;AAClC,YAAM,IAAI6C,KAAJ,CAAU,qBAAqB7C,GAA/B,CAAN;AACD;;AAED,QAAI8C,MAAM,GAAG,KAAKlC,MAAL,CAAYC,OAAZ,CAAoBb,GAApB,CAAb;AACA,QAAI+C,cAAc,GAAG,OAAOD,MAAP,KAAkB,QAAvC;;AAEA,QAAIC,cAAJ,EAAoB;AAClB,UAAIvB,OAAO,IAAI,OAAOA,OAAO,CAACwB,WAAf,KAA+B,WAA9C,EAA2D;AACzD,YAAIC,MAAM,GAAG,KAAKrC,MAAL,CAAYE,SAAZ,CAAsBU,OAAO,CAACwB,WAA9B,CAAb;AACA,eAAO,KAAK1B,WAAL,CAAiBwB,MAAM,CAACG,MAAD,CAAvB,EAAiCzB,OAAjC,CAAP;AACD,OAHD,MAGO;AACL,cAAM,IAAIqB,KAAJ,CAAU,wFAAV,CAAN;AACD;AACF;;AAED,WAAO,KAAKvB,WAAL,CAAiBwB,MAAjB,EAAyBtB,OAAzB,CAAP;AACD,GAlBD;;AAoBA,SAAOf,UAAP;AACD,CApJ6B,EAA9B","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nvar has = require('./hasProperty');\n/**\n * Translates strings with interpolation & pluralization support.\n * Extensible with custom dictionaries and pluralization functions.\n *\n * Borrows heavily from and inspired by Polyglot https://github.com/airbnb/polyglot.js,\n * basically a stripped-down version of it. Differences: pluralization functions are not hardcoded\n * and can be easily added among with dictionaries, nested objects are used for pluralization\n * as opposed to `||||` delimeter\n *\n * Usage example: `translator.translate('files_chosen', {smart_count: 3})`\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {object|Array<object>} locales - locale or list of locales.\n   */\n  function Translator(locales) {\n    var _this = this;\n\n    this.locale = {\n      strings: {},\n      pluralize: function pluralize(n) {\n        if (n === 1) {\n          return 0;\n        }\n\n        return 1;\n      }\n    };\n\n    if (Array.isArray(locales)) {\n      locales.forEach(function (locale) {\n        return _this._apply(locale);\n      });\n    } else {\n      this._apply(locales);\n    }\n  }\n\n  var _proto = Translator.prototype;\n\n  _proto._apply = function _apply(locale) {\n    if (!locale || !locale.strings) {\n      return;\n    }\n\n    var prevLocale = this.locale;\n    this.locale = _extends({}, prevLocale, {\n      strings: _extends({}, prevLocale.strings, locale.strings)\n    });\n    this.locale.pluralize = locale.pluralize || prevLocale.pluralize;\n  }\n  /**\n   * Takes a string with placeholder variables like `%{smart_count} file selected`\n   * and replaces it with values from options `{smart_count: 5}`\n   *\n   * @license https://github.com/airbnb/polyglot.js/blob/master/LICENSE\n   * taken from https://github.com/airbnb/polyglot.js/blob/master/lib/polyglot.js#L299\n   *\n   * @param {string} phrase that needs interpolation, with placeholders\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {string} interpolated\n   */\n  ;\n\n  _proto.interpolate = function interpolate(phrase, options) {\n    var _String$prototype = String.prototype,\n        split = _String$prototype.split,\n        replace = _String$prototype.replace;\n    var dollarRegex = /\\$/g;\n    var dollarBillsYall = '$$$$';\n    var interpolated = [phrase];\n\n    for (var arg in options) {\n      if (arg !== '_' && has(options, arg)) {\n        // Ensure replacement value is escaped to prevent special $-prefixed\n        // regex replace tokens. the \"$$$$\" is needed because each \"$\" needs to\n        // be escaped with \"$\" itself, and we need two in the resulting output.\n        var replacement = options[arg];\n\n        if (typeof replacement === 'string') {\n          replacement = replace.call(options[arg], dollarRegex, dollarBillsYall);\n        } // We create a new `RegExp` each time instead of using a more-efficient\n        // string replace so that the same argument can be replaced multiple times\n        // in the same phrase.\n\n\n        interpolated = insertReplacement(interpolated, new RegExp('%\\\\{' + arg + '\\\\}', 'g'), replacement);\n      }\n    }\n\n    return interpolated;\n\n    function insertReplacement(source, rx, replacement) {\n      var newParts = [];\n      source.forEach(function (chunk) {\n        // When the source contains multiple placeholders for interpolation,\n        // we should ignore chunks that are not strings, because those\n        // can be JSX objects and will be otherwise incorrectly turned into strings.\n        // Without this condition we’d get this: [object Object] hello [object Object] my <button>\n        if (typeof chunk !== 'string') {\n          return newParts.push(chunk);\n        }\n\n        split.call(chunk, rx).forEach(function (raw, i, list) {\n          if (raw !== '') {\n            newParts.push(raw);\n          } // Interlace with the `replacement` value\n\n\n          if (i < list.length - 1) {\n            newParts.push(replacement);\n          }\n        });\n      });\n      return newParts;\n    }\n  }\n  /**\n   * Public translate method\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used later to replace placeholders in string\n   * @returns {string} translated (and interpolated)\n   */\n  ;\n\n  _proto.translate = function translate(key, options) {\n    return this.translateArray(key, options).join('');\n  }\n  /**\n   * Get a translation and return the translated and interpolated parts as an array.\n   *\n   * @param {string} key\n   * @param {object} options with values that will be used to replace placeholders\n   * @returns {Array} The translated and interpolated parts, in order.\n   */\n  ;\n\n  _proto.translateArray = function translateArray(key, options) {\n    if (!has(this.locale.strings, key)) {\n      throw new Error(\"missing string: \" + key);\n    }\n\n    var string = this.locale.strings[key];\n    var hasPluralForms = typeof string === 'object';\n\n    if (hasPluralForms) {\n      if (options && typeof options.smart_count !== 'undefined') {\n        var plural = this.locale.pluralize(options.smart_count);\n        return this.interpolate(string[plural], options);\n      } else {\n        throw new Error('Attempted to use a string with plural forms, but no value was given for %{smart_count}');\n      }\n    }\n\n    return this.interpolate(string, options);\n  };\n\n  return Translator;\n}();"]},"metadata":{},"sourceType":"script"}