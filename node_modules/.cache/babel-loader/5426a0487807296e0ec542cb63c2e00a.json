{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport React from 'react';\n\nvar extractPropsFromString = function extractPropsFromString(attr) {\n  var propsStr = attr.match(/\\s*([^=]*)\\s*=\\s*\"([^\"]*)\"/gi) || [];\n  return Object.assign.apply(Object, [{}].concat(propsStr.map(function (s) {\n    var _ref;\n\n    var arr = s.split('=');\n    return _ref = {}, _ref[(arr[0] || '').trim()] = (arr[1] || '').replace(/\\s*[\"]+/g, ''), _ref;\n  }).flat()));\n};\n\nvar cloneElement = function cloneElement(el, lastChild) {\n  if (!el) return [];\n  if (!Array.isArray(lastChild)) lastChild = [lastChild];\n\n  if (el.props && el.props.children) {\n    return React.cloneElement(el, {}, cloneElement(el.props.children, lastChild));\n  } else if (el.props) {\n    return React.cloneElement(el, {}, [].concat(lastChild));\n  } else {\n    return [el, [].concat(lastChild)];\n  }\n};\n/**\n * \n * const fn = (tag, props) => {\n    if (tag === 'mention') {\n      return <MentionBlock />;\n    }\n    if (tag === 'bold') {\n      return <b />;\n    }\n    if (tag === 'italic') {\n      return <i />;\n    }\n  }\n */\n\n\nvar parseText = function parseText() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n  var tags = [];\n  var preTreeLen = 0;\n  var nodes = [];\n  var matches = text.matchAll(/<\\s*(\\/\\s*)*([^>\\s]*)[^><]*>/gi);\n  matches = Array.from(matches);\n\n  for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref2 = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref2 = _i.value;\n    }\n\n    var match = _ref2;\n    var substring = match[0],\n        isClosing = match[1],\n        tag = match[2];\n    var index = match['index'];\n    tag = (tag || '').trim();\n    isClosing = (isClosing || '').trim();\n    substring = (substring || '').trim();\n\n    if (!isClosing) {\n      tags.push({\n        tag: tag,\n        substring: substring,\n        index: index\n      });\n    } else if (isClosing && tags.length > 0 && tag === tags[tags.length - 1].tag) {\n      var tagObj = tags.pop();\n      var _substring = tagObj.substring,\n          _tag = tagObj.tag;\n\n      var attr = _substring.replace(/[<>]/gi, '').replace(_tag, '');\n\n      var props = extractPropsFromString(attr);\n      var JsxEl = fn(_tag, _extends({}, props));\n      JsxEl = cloneElement(JsxEl, text.slice(text.indexOf('>', tagObj.index) + 1, text.indexOf('<', tagObj.index + 1)));\n      nodes = [].concat(nodes);\n\n      if (preTreeLen <= tags.length) {\n        nodes = [].concat(nodes, [JsxEl, text.slice(text.indexOf('>', index) + 1, text.indexOf('<', index + 1) == -1 ? Infinity : text.indexOf('<', index + 1))]);\n      } else {\n        nodes = cloneElement(JsxEl, nodes);\n      }\n\n      preTreeLen = tags.length;\n    } else {\n      throw Error('Invalid string, no matching tag \"' + tag + '\"');\n    }\n  }\n\n  if (tags.length !== 0) {\n    throw Error('Invalid string, no matching tags : \"' + (tags.map(function (t) {\n      return t.tag;\n    }) || '').toString() + '\"');\n  }\n\n  return [text.slice(0, text.indexOf('<') == -1 ? Infinity : text.indexOf('<'))].concat(nodes);\n};\n\nexport default parseText;","map":{"version":3,"sources":["/home/devnineteen/Desktop/Projects/Evergreen-client/node_modules/react-html-replace/es/index.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","React","extractPropsFromString","attr","propsStr","match","apply","concat","map","s","_ref","arr","split","trim","replace","flat","cloneElement","el","lastChild","Array","isArray","props","children","parseText","text","undefined","fn","tags","preTreeLen","nodes","matches","matchAll","from","_iterator","_isArray","_i","Symbol","iterator","_ref2","next","done","value","substring","isClosing","tag","index","push","tagObj","pop","_substring","_tag","JsxEl","slice","indexOf","Infinity","Error","t","toString"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport React from 'react';\n\nvar extractPropsFromString = function extractPropsFromString(attr) {\n  var propsStr = attr.match(/\\s*([^=]*)\\s*=\\s*\"([^\"]*)\"/gi) || [];\n  return Object.assign.apply(Object, [{}].concat(propsStr.map(function (s) {\n    var _ref;\n\n    var arr = s.split('=');\n    return _ref = {}, _ref[(arr[0] || '').trim()] = (arr[1] || '').replace(/\\s*[\"]+/g, ''), _ref;\n  }).flat()));\n};\n\nvar cloneElement = function cloneElement(el, lastChild) {\n  if (!el) return [];\n  if (!Array.isArray(lastChild)) lastChild = [lastChild];\n  if (el.props && el.props.children) {\n    return React.cloneElement(el, {}, cloneElement(el.props.children, lastChild));\n  } else if (el.props) {\n    return React.cloneElement(el, {}, [].concat(lastChild));\n  } else {\n    return [el, [].concat(lastChild)];\n  }\n};\n\n/**\n * \n * const fn = (tag, props) => {\n    if (tag === 'mention') {\n      return <MentionBlock />;\n    }\n    if (tag === 'bold') {\n      return <b />;\n    }\n    if (tag === 'italic') {\n      return <i />;\n    }\n  }\n */\n\nvar parseText = function parseText() {\n  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};\n\n  var tags = [];\n  var preTreeLen = 0;\n  var nodes = [];\n  var matches = text.matchAll(/<\\s*(\\/\\s*)*([^>\\s]*)[^><]*>/gi);\n  matches = Array.from(matches);\n\n  for (var _iterator = matches, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref2;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref2 = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref2 = _i.value;\n    }\n\n    var match = _ref2;\n    var substring = match[0],\n        isClosing = match[1],\n        tag = match[2];\n\n    var index = match['index'];\n    tag = (tag || '').trim();\n    isClosing = (isClosing || '').trim();\n    substring = (substring || '').trim();\n    if (!isClosing) {\n      tags.push({ tag: tag, substring: substring, index: index });\n    } else if (isClosing && tags.length > 0 && tag === tags[tags.length - 1].tag) {\n      var tagObj = tags.pop();\n      var _substring = tagObj.substring,\n          _tag = tagObj.tag;\n\n      var attr = _substring.replace(/[<>]/gi, '').replace(_tag, '');\n      var props = extractPropsFromString(attr);\n      var JsxEl = fn(_tag, _extends({}, props));\n\n      JsxEl = cloneElement(JsxEl, text.slice(text.indexOf('>', tagObj.index) + 1, text.indexOf('<', tagObj.index + 1)));\n\n      nodes = [].concat(nodes);\n\n      if (preTreeLen <= tags.length) {\n        nodes = [].concat(nodes, [JsxEl, text.slice(text.indexOf('>', index) + 1, text.indexOf('<', index + 1) == -1 ? Infinity : text.indexOf('<', index + 1))]);\n      } else {\n        nodes = cloneElement(JsxEl, nodes);\n      }\n      preTreeLen = tags.length;\n    } else {\n      throw Error('Invalid string, no matching tag \"' + tag + '\"');\n    }\n  }\n  if (tags.length !== 0) {\n    throw Error('Invalid string, no matching tags : \"' + (tags.map(function (t) {\n      return t.tag;\n    }) || '').toString() + '\"');\n  }\n  return [text.slice(0, text.indexOf('<') == -1 ? Infinity : text.indexOf('<'))].concat(nodes);\n};\n\nexport default parseText;"]},"metadata":{},"sourceType":"module"}