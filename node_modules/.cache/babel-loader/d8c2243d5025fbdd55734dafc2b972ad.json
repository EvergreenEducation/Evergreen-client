{"ast":null,"code":"/**\n * Array.prototype.findIndex ponyfill for old browsers.\n */\nfunction findIndex(array, predicate) {\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) return i;\n  }\n\n  return -1;\n}\n\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n\n  var _proto = RateLimitedQueue.prototype;\n\n  _proto._call = function _call(fn) {\n    var _this = this;\n\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n\n        _this._queueNext();\n      }\n    };\n  };\n\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this; // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n\n\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n\n    var next = this.queuedHandlers.shift();\n\n    var handler = this._call(next.fn);\n\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n\n    return handler;\n  };\n\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n\n    return this._queue(fn, queueOptions);\n  };\n\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n\n      return outerPromise;\n    };\n  };\n\n  return RateLimitedQueue;\n}();","map":{"version":3,"sources":["/home/devnineteen/Desktop/Projects/Evergreen-client/node_modules/@uppy/utils/lib/RateLimitedQueue.js"],"names":["findIndex","array","predicate","i","length","createCancelError","Error","module","exports","RateLimitedQueue","limit","Infinity","activeRequests","queuedHandlers","_proto","prototype","_call","fn","_this","_done","cancelActive","err","abort","_queueNext","done","_this2","Promise","resolve","then","_next","next","shift","handler","_queue","options","_this3","priority","_dequeue","index","other","push","splice","indexOf","run","queueOptions","wrapPromiseFunction","_this4","_len","arguments","args","Array","_key","queuedRequest","outerPromise","reject","cancelError","innerPromise","apply","result"],"mappings":"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","sourcesContent":["/**\n * Array.prototype.findIndex ponyfill for old browsers.\n */\nfunction findIndex(array, predicate) {\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) return i;\n  }\n\n  return -1;\n}\n\nfunction createCancelError() {\n  return new Error('Cancelled');\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function RateLimitedQueue(limit) {\n    if (typeof limit !== 'number' || limit === 0) {\n      this.limit = Infinity;\n    } else {\n      this.limit = limit;\n    }\n\n    this.activeRequests = 0;\n    this.queuedHandlers = [];\n  }\n\n  var _proto = RateLimitedQueue.prototype;\n\n  _proto._call = function _call(fn) {\n    var _this = this;\n\n    this.activeRequests += 1;\n    var _done = false;\n    var cancelActive;\n\n    try {\n      cancelActive = fn();\n    } catch (err) {\n      this.activeRequests -= 1;\n      throw err;\n    }\n\n    return {\n      abort: function abort() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n        cancelActive();\n\n        _this._queueNext();\n      },\n      done: function done() {\n        if (_done) return;\n        _done = true;\n        _this.activeRequests -= 1;\n\n        _this._queueNext();\n      }\n    };\n  };\n\n  _proto._queueNext = function _queueNext() {\n    var _this2 = this;\n\n    // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n    // one by one without continuously _advancing_ it (and starting new tasks before immediately\n    // aborting them)\n    Promise.resolve().then(function () {\n      _this2._next();\n    });\n  };\n\n  _proto._next = function _next() {\n    if (this.activeRequests >= this.limit) {\n      return;\n    }\n\n    if (this.queuedHandlers.length === 0) {\n      return;\n    } // Dispatch the next request, and update the abort/done handlers\n    // so that cancelling it does the Right Thing (and doesn't just try\n    // to dequeue an already-running request).\n\n\n    var next = this.queuedHandlers.shift();\n\n    var handler = this._call(next.fn);\n\n    next.abort = handler.abort;\n    next.done = handler.done;\n  };\n\n  _proto._queue = function _queue(fn, options) {\n    var _this3 = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var handler = {\n      fn: fn,\n      priority: options.priority || 0,\n      abort: function abort() {\n        _this3._dequeue(handler);\n      },\n      done: function done() {\n        throw new Error('Cannot mark a queued request as done: this indicates a bug');\n      }\n    };\n    var index = findIndex(this.queuedHandlers, function (other) {\n      return handler.priority > other.priority;\n    });\n\n    if (index === -1) {\n      this.queuedHandlers.push(handler);\n    } else {\n      this.queuedHandlers.splice(index, 0, handler);\n    }\n\n    return handler;\n  };\n\n  _proto._dequeue = function _dequeue(handler) {\n    var index = this.queuedHandlers.indexOf(handler);\n\n    if (index !== -1) {\n      this.queuedHandlers.splice(index, 1);\n    }\n  };\n\n  _proto.run = function run(fn, queueOptions) {\n    if (this.activeRequests < this.limit) {\n      return this._call(fn);\n    }\n\n    return this._queue(fn, queueOptions);\n  };\n\n  _proto.wrapPromiseFunction = function wrapPromiseFunction(fn, queueOptions) {\n    var _this4 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var queuedRequest;\n      var outerPromise = new Promise(function (resolve, reject) {\n        queuedRequest = _this4.run(function () {\n          var cancelError;\n          var innerPromise;\n\n          try {\n            innerPromise = Promise.resolve(fn.apply(void 0, args));\n          } catch (err) {\n            innerPromise = Promise.reject(err);\n          }\n\n          innerPromise.then(function (result) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              resolve(result);\n            }\n          }, function (err) {\n            if (cancelError) {\n              reject(cancelError);\n            } else {\n              queuedRequest.done();\n              reject(err);\n            }\n          });\n          return function () {\n            cancelError = createCancelError();\n          };\n        }, queueOptions);\n      });\n\n      outerPromise.abort = function () {\n        queuedRequest.abort();\n      };\n\n      return outerPromise;\n    };\n  };\n\n  return RateLimitedQueue;\n}();"]},"metadata":{},"sourceType":"script"}