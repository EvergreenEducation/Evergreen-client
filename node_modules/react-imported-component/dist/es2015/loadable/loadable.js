import { settings } from '../configuration/config';
import { isBackend } from '../utils/detectBackend';
import { getFunctionSignature, importMatch } from '../utils/signatures';
import { assingLoadableMark } from './marks';
import { getPreloaders } from './preloaders';
var pending = [];
var LOADABLE_WEAK_SIGNATURE = new WeakMap();
var LOADABLE_SIGNATURE = new Map();
var addPending = function (promise) { return pending.push(promise); };
var removeFromPending = function (promise) { return (pending = pending.filter(function (a) { return a !== promise; })); };
var toKnownSignature = function (signature, marks) {
    return (!settings.checkSignatures && marks.join('|')) || signature;
};
export function toLoadable(firstImportFunction, autoImport) {
    if (autoImport === void 0) { autoImport = true; }
    var importFunction = firstImportFunction;
    var loadImportedComponent = function () {
        return Promise.all([importFunction()].concat(getPreloaders())).then(function (_a) {
            var result = _a[0];
            return result;
        });
    };
    var functionSignature = getFunctionSignature(importFunction);
    var mark = importMatch(functionSignature);
    var resolveResolution;
    var resolution = new Promise(function (r) {
        resolveResolution = r;
    });
    var loadable = {
        // importFunction,
        mark: mark,
        resolution: resolution,
        done: false,
        ok: false,
        error: null,
        payload: undefined,
        promise: undefined,
        isLoading: function () {
            return !!this.promise && !this.done;
        },
        reset: function () {
            this.done = false;
            this.ok = true;
            this.payload = undefined;
            this.promise = undefined;
        },
        replaceImportFunction: function (newImportFunction) {
            importFunction = newImportFunction;
        },
        get importer() {
            return importFunction;
        },
        then: function (cb, err) {
            if (this.promise) {
                return this.promise.then(cb, err);
            }
            if (err) {
                err();
            }
            return Promise.reject();
        },
        loadIfNeeded: function () {
            if (this.error) {
                this.reset();
            }
            if (!this.promise) {
                this.load();
            }
            return this.promise;
        },
        tryResolveSync: function (then) {
            if (this.done) {
                var result_1 = then(this.payload);
                return {
                    then: function (cb) {
                        // synchronous thenable - https://github.com/facebook/react/pull/14626
                        cb(result_1);
                        return Promise.resolve(result_1);
                    },
                };
            }
            return this.loadIfNeeded().then(then);
        },
        reload: function () {
            if (this.promise) {
                this.promise = undefined;
                return this.load();
            }
            return Promise.resolve();
        },
        _probeChanges: function () {
            var _this = this;
            return Promise.resolve(importFunction())
                .then(function (payload) { return payload !== _this.payload; })
                .catch(function (err) {
                throw err;
            });
        },
        load: function () {
            var _this = this;
            if (!this.promise) {
                var promise_1 = (this.promise = loadImportedComponent().then(function (payload) {
                    _this.done = true;
                    _this.ok = true;
                    _this.payload = payload;
                    _this.error = null;
                    removeFromPending(promise_1);
                    resolveResolution(payload);
                    return payload;
                }, function (err) {
                    _this.done = true;
                    _this.ok = false;
                    _this.error = err;
                    removeFromPending(promise_1);
                    throw err;
                }));
                addPending(promise_1);
            }
            return this.promise;
        },
    };
    if (mark && mark.length) {
        LOADABLE_SIGNATURE.set(toKnownSignature(functionSignature, mark), loadable);
        assingLoadableMark(mark, loadable);
    }
    else {
        if (process.env.NODE_ENV !== 'development') {
            // tslint:disable-next-line:no-console
            console.warn('react-imported-component: no mark found at', importFunction, 'Please check babel plugin or macro setup, as well as imported-component\'s limitations. See https://github.com/theKashey/react-imported-component/issues/147');
        }
    }
    // trigger preload on the server side
    if (isBackend && autoImport) {
        loadable.load();
    }
    return loadable;
}
var readyFlag = false;
export var isItReady = function () { return readyFlag; };
/**
 * waits for all necessary imports to be fulfilled
 */
export var done = function () {
    if (pending.length) {
        readyFlag = false;
        return Promise.all(pending)
            .then(function (a) { return a[1]; })
            .then(done);
    }
    readyFlag = true;
    return Promise.resolve();
};
/**
 * try to perform a render and loads all chunks required for it
 * @deprecated
 */
export var dryRender = function (renderFunction) {
    renderFunction();
    return Promise.resolve().then(done);
};
export var markMeta = [];
var assignMetaData = function (mark, loadable, chunkName, fileName) {
    markMeta.push({ mark: mark, loadable: loadable, chunkName: chunkName, fileName: fileName });
};
/**
 * to be used __only via CLI tools__
 */
export var assignImportedComponents = function (set) {
    var countBefore = LOADABLE_SIGNATURE.size;
    set.forEach(function (imported) {
        var allowAutoLoad = !(imported[3] || !settings.fileFilter(imported[2]));
        var loadable = toLoadable(imported[0], allowAutoLoad);
        assignMetaData(loadable.mark, loadable, imported[1], imported[2]);
    });
    if (countBefore === LOADABLE_SIGNATURE.size) {
        // tslint:disable-next-line:no-console
        console.error('react-imported-component: no import-marks found, please check babel plugin');
    }
    done();
    return set;
};
export function executeLoadable(importFunction) {
    if ('resolution' in importFunction) {
        return importFunction.reload();
    }
    else {
        return importFunction();
    }
}
/**
 * wraps an `import` function with a tracker
 * @internal
 * @param importFunction
 */
export function getLoadable(importFunction) {
    if ('resolution' in importFunction) {
        return importFunction;
    }
    if (LOADABLE_WEAK_SIGNATURE.has(importFunction)) {
        return LOADABLE_WEAK_SIGNATURE.get(importFunction);
    }
    var rawSignature = getFunctionSignature(importFunction);
    var ownMark = importMatch(String(rawSignature));
    // read cache signature
    var functionSignature = toKnownSignature(rawSignature, ownMark);
    if (LOADABLE_SIGNATURE.has(functionSignature)) {
        // tslint:disable-next-line:no-shadowed-variable
        var loadable_1 = LOADABLE_SIGNATURE.get(functionSignature);
        loadable_1.replaceImportFunction(importFunction);
        return loadable_1;
    }
    if (ownMark) {
        LOADABLE_SIGNATURE.forEach(function (_a) {
            var mark = _a.mark, importer = _a.importer;
            if (mark[0] === ownMark[1] && mark.join('|') === ownMark.join('|')) {
                // tslint:disable-next-line:no-console
                console.warn('Another loadable found for an existing mark. That\'s possible, but signatures must match (https://github.com/theKashey/react-imported-component/issues/192):', {
                    mark: mark,
                    knownImporter: importer,
                    currentImported: importFunction,
                    currentSignature: String(importFunction),
                    knownSignature: String(importer),
                });
            }
        });
    }
    var loadable = toLoadable(importFunction);
    LOADABLE_WEAK_SIGNATURE.set(importFunction, loadable);
    return loadable;
}
/**
 * Reset `importers` weak cache
 * @internal
 */
export var clearImportedCache = function () { return LOADABLE_SIGNATURE.clear(); };
